C++ 시험
- 챕터별 요약문제
- 연습문제 

1장
- 아스키아트
- 일반화프로그래밍 (13, 14장)
- 컴파일과정에서 함수중복 매개변수 자료형 확인 가능
ex) int add(int x, int y)  <- add(3, 4)

함수중복, 연산자 중복, 템플릿 -> 컴파일 과정에서 알 수 있음
가상함수 -> 실행과정에서 알 수 있음(컴파일 과정에서 미리 알 수 없음)

컴파일: cpp -> 각각의 obj 파일로 변환
링커: 전역변수 에러, 실행파일 하나, 목적(obj)파일 여러개 -> 하나의 실행파일로 통합하는 과정

2장
- asm ->어셈블러(해당부분을 빠르게 돌리고 싶을 때)
- auto -> ex) auto x = 1; --> auto는 자동으로 int가 됨  ->>>>절대 시험에 안나옴
ex) auto c; (X -> 값 지정을 안함) ---> auto c = 1;
      c= 1; (값을 변경할 수 있다는 소리이므로 자료형이 정확하지 않음)
ex)  const int x; (X --> 잘못된 문장)   ---> const int x = 1;
ex)  int & b; (X)
       int & b = a; (O)

<단락 논리>
int *p = &i;
if(p!=NULL && *p>3)
      F(무조건 F이므로 곱연산이므로 무조건 F)-> 첫번째 연산으로 결과가 정해지면 다음 연산은 하지 않음 
p!=NULL을 빼버리면, 메모리의 0번지를 건들이려고 하는순간 프로그램이 죽어버림

- 연산자 우선순위 문제 나옴 + 최종 결과값의 자료형 문제
- 과제했던 부분에서 어떻게 적용했는지 설명할 수 있는 문제

3장
- 함수만드는 문제(구현 문제)
- C++ 함수중복 허용 후 add(매개변수의 자료형을 무조건 써줘야함)
- 매크로 함수는 일반화프로그래밍
- 디폴트값은 뒤에서부터 채워야 함
- 변수 생존 기간 (3장 17p)
- 코딩하는 문제(정적변수), 설명하는 문제(가시범위)(3장 18p)

4장
- 정수 배열에서 가장 큰 항목을 찾아서 그 항목의 값을 반환하는 원형을 적어라, 함수를 구현하라(문제, 4장 9p)
- 문자열은 길이 전달할 필요 X: 마지막 NULL == \0이므로 문자열이 0이 나올때까지 하다가 0이 나오면 끝남
- min, max = findminmax(A); return min, max; (파이썬만 가능) -> 튜플을 통해 min, max를 괄호로 묶음
- findmm(__A(), int len, int* pMin, int* pMax) ->주소나 참조자형을 넘겨줘서 반환값을 저장해야함
- 다차원 배열은 시험에서 X
- 구조체는 대입연산자만 지원하기 때문에 다른 연산자를 사용하려면 "연산자 중복" 활용
- 참조자는 안전성 X -> 값에 의한 호출(call-by-value)을 사용하는 이유

5장
- int A[5]; ->배열 A의 자료형? int*
- p의 자료형? -> Polynimial *
- a의 자료형은 무엇입니까? ->Polynimial
- a.degree의 자료형은 무엇입니까? -> int
- p->degree 자료형?-> int
- a.coef[0] -> float
- a.coef -> float*
- a->degree의 자료형? -> (오류, a->degree가 아예 안됨, a.degree가 되어야 함)
- p.degree의 자료형? ->(오류, p안에 degree없음 p가 가르키는 곳에 degree가 있음)
- findMinMax 시험에 무조건 나옴(참조에 의한 호출)
- map(x,y) = 10; 이렇게 되려면 매개변수의 자료형이 어떻게 되어야하는지 설명하라. ->C++에서만 가능한 코드
  C에서는 y=map(a,b); 이런 모양 가능
  map이 int를 반환하면 저렇게 쓰지 못함
  따라서 map이 int&를 반환하여야 함
- (상수에는 참조 X, 변수에 참조자 붙일 수 있음)
- 재귀호출 시험 X

6장
- UML클래스다이어그램 시험 X
- friend로 선언 -> read함수는 일반함수가 됨(11p inline구현 코드)
- 시험에 string 클래스에 대한건 X -> 표준 라이브러리에 있는 클래스를 어떻게 쓰느냐 ? 이런건 시험 X
- 이진파일과 같은 기본 개념 문제 O

7장 
- 생성자, 소멸자
=> 생성자와 일반함수 차이점: 생성자는 반환형이 없고, 이름이 클래스와 동일. 멤버 초기화리스트 사용가능. 객체 생성시 오직 한번만 호출
=> 생성자와 일반함수 공통점: 멤버 변수나 멤버 함수 사용가능, 함수 중복 가능, 디폴트 매개변수 선언 가능
- 멤버 초기화 리스트
=> 사용하는 이유
1) 클래스 상수 멤버나 참조자 멤버 초기화
2) 다른클래스의 객체 멤버로 갖는 경우 이들을 초기화
3) 상속관계에서 부모클래스의 생성자를 골라서 초기화
- 생성자 호출 순서 무조건 시험에 나옴(시험)
- 메인함수에 Point list[10];만 있으면 디폴트 생성자가 10번 생성, 소멸자도 10번 호출됨(시험)
- 7장 14p, add(a, b, c);에서 자료형 a, b -> Complex, c->Complex*
포, 포, 포
컴(컴포), 컴(컴포), 컴
컴 컴, C의 멤버함수
a자신과 b를 더함, 컴(연산자 중복)

8장
- 4p 포인터와 객체의 멤버 접근-> 자료형 문제(시험문제)
- 동적 메모리 할당과 해제(new, delet) 1차원배열 할당 해제 사용 (시험문제)
- 얕깊 개념, 왜 발생하는지, 왜 필요한지 설명할 수 있어야함 (코드적으로 깊이있게 문제 내지는 않을것임)
//////
=> 앝은 복사의 경우 Vertor 객체에서는 동적으로 할당된 메모리 공간이 있는데, 컴파일러는 이 공간을 알지 못하므로
무조건적인 복사를 하였을 때 복사된 객체 영역과 실제 객체 영역이 같은 곳을 가리키게 된다. 따라서 객체가 소멸될때
문제가 발생한다. 복사된 객체의 영역이 소멸될 때 arr가 가리키는 영역을 동적으로 해제한 후, 실제 객체가 소멸할 때
실제 객체의 arr가 가리키는 곳을 해제하려고 하는데 이미 해제된 영역이므로 실행 오류가 발생한다.
=> 소심한 해결방안: 참조자, 포인터 // 근본적인 해결방안: 깊은 복사(동적으로 할당된 공간까지 같이 복사시킴)
//////
- this 본인의 주소
- 함수안에서 static지역함수변수가 어떻게 되는지 코드하는 문제
=> 정적 지역변수는 전역변수와 동일한 생존기간을 가짐: 사용은 함수 내에서만 가능하지만 프로그램 실행 동안 계속 생존
=> 함수 호출과 상관없이 프로그램 시작 시 초기화되어 함수가 아니라 프로그램이 종료되어야 사라짐
=> 따라서 다음에 함수가 호출되어도 이전 값을 계속 유지
- 전역변수나 전역함수를 static으로 선언했을 때 어떻게 실행되는지 문제
=> static은 전역변수와 전역함수의 가시범위를 해당 파일로 국한시켜 링크 과정에서 오류가 발생하지 않도록함
=> 따라서 다른 파일에서 extern으로 해당 정적 전역 변수 및 함수를 선언하여 사용할 수 없다.
- 클래스 내에 static으로 선언했을 때 어떻게 실행되는지 문제(8장 14p)
=> 객체단위의 멤버가 아닌 클래스 단위의 멤버를 선언할 수 있음
- 정적멤버변수의 경우 cpp파일에 따로 코드추가(정적 멤버함수는 상관없음)
- 2차원배열 동적 할당 시험 X

9장
- 상속에서 protected나옴
- 9장 8p 시험 X(부모 클래스를 상속받는 방법들)
- 상속에서 생성자의 호출순서(몸체의 호출순서) 시험 문제 나옴(9장 9p)
- 생성은 부모 클래스부터 생성됨(몸체 순서)
- 소멸은 자식클래스부터 소멸됨(몸체 소멸)
- 멤버변수 재정의(바람직하지 않음)
- 멤버함수 재정의(overriding, 매우 중요!)
- 매개변수 다르면 중복정의(ex.과제에서 Toman 함수)
- 다중상속 시험 X
- 과제했던것중에 뭐를 왜 썼는지 의미 제대로 알아야함 -> 시험문제 출제
=>상속되지 않는 함수들 : 부모클래스의 private멤버함수, 생성자, 소멸자, 복사생성자, 대입연산자 중복 함수

10장
 - 몬스터의 move함수를 virtual 로 선언
- 클래스 하나, 상속 여러개, 클래스의 멤버함수 두개쯤 둘중 하나는 virtual , 하나는 virtual 선언X
자식클래스 재정의 , 이함수 저함수 불러보면서 virtual 로 선언된 멤버함수는 그 클래스가 속한 멤버함수가 호출,
그렇지 않은 함수는 부모클래스의 멤버함수가 호출 (시험문제 출제)(10장 15p)
- 가상함수 객체크기, 프로젝트 플랫폼별 차이(10장 12-13p)
- 가상소멸자는 기본적으로 사용
- virtual move() = 0; -> 여기서 함수 안만들고 선언만 해놓은 뒤, 자식클래스에서 만드는 것(순수 가상 함수)
- 순수가상함수 move를 사용하면 자식클래스에서 모두다 move함수를 각자 만들어야함

11장

문제팁
- 시험지는 4p
- 괄호채우기(요약문제)
- 자료형 묻는 문제들
- 연산 순서 어떻게 되는지, 최종 자료형이 뭔지
- 어떠어떤것을 하는 함수의 원형을 적어라
- 생성자 소멸자 코드 주어짐 -> 화면에 어떻게 출력되는지(몸체 호출순서)
- 가상함수이냐 아니냐에 따른 클래스를 만들어서 루프 돌렸을 때 어떻게 출력되느냐
- 연산자 중복
- 설명하는 것 중요(맨 뒷장 여러문제 출제->과제에서 어떤 것을 왜 사용했는지, 중간중간 수업시간에 설명문제 낸다고 했던것)
- 코드하는 것 (static 변수, findMinMax 배열 참조자 등등 문제)
- 빈칸 왕창, 자료형 왕창, 함수선언 왕창, 설명하는 문제, 실행이 어떻게 되는가, 코드 구현하는것